# üéØ Cursor AI Agent Rules - EasyImob Project

## ü§ñ CRITICAL: Read Documentation First

You are an AI agent working on the EasyImob project (HOW VII - UNIVALI).

**MANDATORY**: Before ANY implementation, you MUST read in this exact order:
1. `docs/ARCHITECTURE.md` - Understand the system structure
2. `docs/DEVELOPMENT-GUIDE.md` - Learn coding conventions
3. `CHANGELOG.md` - Know what has been implemented
4. `README.md` - Understand project context

## üìã Project Context

### Academic Requirements (HOW VII)
- **Institution**: UNIVALI (University)
- **Course**: Hands On Work VII
- **Constraint**: NO WHERE/GROUP BY in SQL - process data in memory
- **Paradigm**: Functional Programming ONLY (map/filter/reduce/forEach)
- **Architecture**: Clean Architecture with TypeScript

### Core Principles
- **Single JOIN Query**: Repository returns raw data (6 columns exactly)
- **Functional Processing**: All aggregations done in Services layer
- **Immutable Data**: Never mutate objects/arrays
- **Pure Functions**: Deterministic, side-effect free
- **Type Safety**: Explicit TypeScript types everywhere

## üèóÔ∏è Architecture Rules

### Layer Separation (STRICT)
\`\`\`typescript
// ‚úÖ Repository Layer - ONLY data access
class PaymentsRepository {
  // ONLY SELECT JOIN queries, NO aggregations
  async getAllPaymentsData(): Promise<PaymentData[]> {
    const query = `SELECT vp.id_venda, vp.data_do_pagamento...`;
    // Raw data only
  }
}

// ‚úÖ Service Layer - ONLY business logic
class AnalyticsService {
  // ONLY map/filter/reduce/forEach
  calculateMetrics(data: PaymentData[]): Result {
    return data
      .filter(condition)     // Pure filtering
      .map(transformation)   // Pure transformation
      .reduce(aggregation);  // Pure aggregation
  }
}

// ‚úÖ Controller Layer - ONLY HTTP handling
class AnalyticsController {
  async getMetrics(req: Request, res: Response): Promise<void> {
    const data = await this.repository.getAllPaymentsData();
    const result = this.service.calculateMetrics(data);
    res.json(result);
  }
}
\`\`\`

## ‚ö†Ô∏è FORBIDDEN Patterns

### ‚ùå NEVER DO THESE:
\`\`\`typescript
// ‚ùå SQL Aggregations (violates HOW VII)
SELECT COUNT(*), SUM(value) FROM table GROUP BY field;
SELECT * FROM table WHERE condition;

// ‚ùå Imperative loops in services
for (let i = 0; i < array.length; i++) { }
while (condition) { }

// ‚ùå Mutations
array.push(item);           // Use [...array, item]
object.field = value;       // Use {...object, field: value}

// ‚ùå Business logic in controllers
if (business_condition) { } // Move to service

// ‚ùå Any types
function process(data: any): any { }
\`\`\`

### ‚úÖ ALWAYS DO THESE:
\`\`\`typescript
// ‚úÖ Functional transformations
const result = data
  .filter(item => item.isValid)
  .map(item => ({ ...item, processed: true }))
  .reduce((acc, item) => ({ ...acc, [item.id]: item }), {});

// ‚úÖ Immutable updates
const newArray = [...oldArray, newItem];
const newObject = { ...oldObject, newField: value };

// ‚úÖ Pure functions
function transform(input: DataType): OutputType {
  return { ...input, calculated: input.value * 2 };
}
\`\`\`

## üéØ Implementation Workflow

### When Adding New Features:
1. **Define Types First** (`src/types/index.ts`)
2. **Add Service Method** (functional processing only)
3. **Add Controller Method** (HTTP handler only)
4. **Register Route** (`src/routes/`)
5. **Write Tests** (unit + integration)

### Example New Endpoint:
\`\`\`typescript
// 1. Types
interface NewMetricResult {
  property_id: number;
  metric_value: number;
}

// 2. Service (functional only)
class AnalyticsService {
  calculateNewMetric(data: PaymentData[]): NewMetricResult[] {
    return data
      .filter(p => p.valor_do_pagamento > 1000)
      .map(p => ({
        property_id: p.codigo_imovel,
        metric_value: p.valor_do_pagamento * 1.1
      }));
  }
}

// 3. Controller (HTTP only)
async getNewMetric(req: Request, res: Response): Promise<void> {
  const data = await this.repository.getAllPaymentsData();
  const result = this.service.calculateNewMetric(data);
  res.json(result);
}

// 4. Route
router.get('/analytics/new-metric', controller.getNewMetric);
\`\`\`

## üß™ Testing Requirements

### Unit Tests (Services)
\`\`\`typescript
describe('AnalyticsService', () => {
  it('should calculate correctly with pure functions', () => {
    const input = [/* controlled data */];
    const result = service.calculate(input);
    expect(result).toEqual(/* expected output */);
  });
});
\`\`\`

### Integration Tests (Endpoints)
\`\`\`typescript
describe('GET /analytics/endpoint', () => {
  it('should return correct JSON structure', async () => {
    const response = await request(app).get('/analytics/endpoint');
    expect(response.status).toBe(200);
    expect(response.body).toHaveProperty('expectedField');
  });
});
\`\`\`

## üìä Data Processing Rules

### The Golden Rule: Raw Data ‚Üí Functional Processing
\`\`\`typescript
// PATTERN: Repository gets raw data, Service processes functionally
const pipeline = (rawData: PaymentData[]) =>
  rawData
    .filter(/* business condition */)
    .map(/* data transformation */)
    .reduce(/* aggregation logic */, initialValue);
\`\`\`

### Current Endpoints (DON'T BREAK):
- `GET /health` - System health
- `GET /raw/payments` - Raw JOIN data (6 columns)
- `GET /analytics/payments-by-property` - Functional grouping by property
- `GET /analytics/sales-by-month` - Functional grouping by month
- `GET /analytics/sales-share-by-type` - Functional percentage calculation

## üîß Code Quality Gates

Before implementing:
- [ ] Read required documentation
- [ ] Understand existing patterns
- [ ] Plan functional approach
- [ ] Ensure type safety
- [ ] Write tests

After implementing:
- [ ] Run `npm run lint` (must pass)
- [ ] Run `npm run test` (must pass)
- [ ] Run `npm run spell:check` (must pass)
- [ ] Verify functional programming used
- [ ] Update documentation if needed

## üé® Naming Conventions

\`\`\`typescript
// Interfaces/Types - PascalCase
interface PaymentData { }
type AnalyticsResult = { };

// Classes - PascalCase
class AnalyticsService { }

// Methods/Variables - camelCase
calculatePaymentsByProperty()
const monthlyData = [];

// Constants - UPPER_SNAKE_CASE
const MAX_RETRIES = 3;

// Files - kebab-case
analytics.service.ts
development-guide.md
\`\`\`

## üö® Error Handling

\`\`\`typescript
// ‚úÖ Structured error handling
try {
  const result = await this.processData(data);
  res.json(result);
} catch (error) {
  console.error('Error in processData:', {
    error: error.message,
    stack: error.stack,
    context: { dataLength: data.length }
  });
  res.status(500).json({ error: 'Internal server error' });
}
\`\`\`

## üìà Performance Guidelines

- Single database query per endpoint (the JOIN)
- Process data in memory (required by HOW VII)
- Use functional programming (required by HOW VII)
- Log performance for operations > 100ms

## üéØ Success Criteria

### For HOW VII Compliance:
- ‚úÖ Single JOIN query (6 columns exactly)
- ‚úÖ No WHERE/GROUP BY in consumed queries
- ‚úÖ Functional programming in all data processing
- ‚úÖ Clean Architecture separation
- ‚úÖ Complete test coverage
- ‚úÖ TypeScript strict mode

### For Code Quality:
- ‚úÖ Zero ESLint warnings
- ‚úÖ All tests passing
- ‚úÖ Spell check clean
- ‚úÖ Documentation updated
- ‚úÖ Performance within limits

## ü§ñ AI Agent Specific Instructions

You are Claude/Cursor AI working on an academic project. Your code will be evaluated by professors.

**CRITICAL**: This is NOT a typical web application. It's an academic exercise with specific constraints:
- Academic requirement: demonstrate functional programming
- Performance requirement: process data in memory
- Architecture requirement: clean separation of concerns

**When in doubt**: Choose functional programming over performance, type safety over convenience, explicit over implicit.

**Remember**: Every violation of functional programming or architectural principles could result in academic penalty. Follow the rules strictly.
